type: edu
files:
- name: src/tracker/Main.java
  visible: true
  text: |
    package tracker;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
  learner_created: false
- name: build.gradle
  visible: true
  text: |
    repositories {
        mavenCentral()
    }

    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
        testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.7.1'
    }

    test {
        useJUnitPlatform()
    }
  learner_created: false
- name: test/tracker/SampleTest.java
  visible: true
  text: |
    package tracker;

    import org.junit.jupiter.api.Test;

    import static org.junit.jupiter.api.Assertions.*;

    public class SampleTest {

        @Test
        void test() {
            assertEquals(5, 2 + 3);
        }
    }
  learner_created: false
- name: test/LearningProgressTrackerTest.java
  visible: false
  text: |
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Collections;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Random;
    import java.util.Set;
    import java.util.function.Predicate;
    import java.util.stream.Collectors;
    import java.util.stream.IntStream;
    import java.util.stream.Stream;

    import static org.hyperskill.hstest.testing.expect.Expectation.expect;

    public class LearningProgressTrackerTest extends StageTest<String> {
        private static final Random rnd = new Random();

        @DynamicTest(order = 1)
        CheckResult testStartAndExit() {
            TestedProgram main = new TestedProgram();
            String output = main.start();
            expect(output).toContain(1).lines();
            if (incorrectString(output, "Learning Progress Tracker")) {
                return CheckResult.wrong("When started, your program " +
                        "should print \"Learning Progress Tracker\"");
            }

            if (!main.isWaitingInput()) {
                return CheckResult.wrong("After the start, your program should " +
                        "be ready to accept commands from the user");
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (!main.isWaitingInput()) {
                return CheckResult.wrong("Your program should keep running after the 'back' " +
                        "command is entered");
            }

            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should print the hint \"Enter 'exit' to exit the program.\"");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 2, data = "getBlankInput")
        CheckResult testBlankInput(String input) {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute(input);
            expect(output).toContain(1).lines();
            if (incorrectString(output, "no input")) {
                return CheckResult.wrong("When the user enters an empty or blank " +
                        "string, your program should print \"No input.\"");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 3, data = "getUnknownCommands")
        CheckResult testUnknownCommands(String input) {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute(input);
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "unknown", "command")) {
                return CheckResult.wrong("When an unknown command is entered, your " +
                        "program should display an error message: \"Unknown command!\"");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 4)
        CheckResult testAddStudents1() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("add students");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output,
                    "enter", "student", "credentials", "back", "return")) {
                return CheckResult.wrong("When 'add students' command is entered, your " +
                        "program should display the prompt \"Enter student credentials or " +
                        "'back' to return:\"");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "incorrect", "credentials")) {
                return CheckResult.wrong("Expected output: \"Incorrect credentials.\", " +
                        "but your output was: " + output);
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "0", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 0 students have been added.\", but " +
                        "your output was: " + output);
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student credentials");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 5)
        CheckResult testAddStudents2() {
            TestedProgram main = new TestedProgram();
            main.start();

            main.execute("add students");
            for (String input : getCorrectCredentials()) {
                String output = main.execute(input);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "10", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 10 students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 6)
        CheckResult testAddStudents3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            for (String[] args : getIncorrectCredentials()) {
                String output = main.execute(args[0]);
                expect(output).toContain(1).lines();
                if (incorrectString(output, args[1])) {
                    return CheckResult.wrong("Expected output: \"" + args[1] + "\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "0", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 0 students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 7)
        CheckResult testFindAll1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");
            main.execute("back");

            String output = main.execute("list");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "no", "found")) {
                return CheckResult.wrong("Expected: \"No students found.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 8)
        CheckResult testAddDoubles() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(12);
            for (String arg : credentials) {
                String output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }

                output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "this", "email", "already", "taken")) {
                    return CheckResult.wrong("Expected output: \"This email is already taken.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", String.valueOf(credentials.size()), "students", "added")) {
                return CheckResult.wrong("Expected: \"Total " + credentials.size() + "students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 9)
        CheckResult testFindAll2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(12);
            for (String arg : credentials) {
                String output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    main.stop();
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", String.valueOf(credentials.size()), "students", "added")) {
                return CheckResult.wrong("Expected: \"Total " + credentials.size() + "students have been added.\", but " +
                        "your output was: " + output);
            }

            output = main.execute("list");
            List<String> lines = expect(output).toContain(credentials.size() + 1).lines();
            if (!lines.get(0).toLowerCase().contains("students")) {
                return CheckResult.wrong("Expected the header \"Students:\" but your first line was: " + lines.get(0));
            }

            List<String> ids = parseIds(lines);
            Set<String> uniqueIds = new HashSet<>(ids);
            if (uniqueIds.size() != ids.size()) {
                return CheckResult.wrong("Expected " + ids.size() +
                        " unique IDs but found only " + uniqueIds.size());
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 10)
        CheckResult testBackFromAddPoints() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("add points");
            expect(output).toContain().lines();
            if (anyMissingKeywords(output, "enter", "id", "points", "back", "return")) {
                return CheckResult.wrong("When 'add points' command is entered, your program should print " +
                        "\"Enter an id and points or 'back' to return:\" but your output was: " + output);
            }

            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id and points");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 11)
        CheckResult testStudentPoints1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(6);
            for (String arg : credentials) {
                main.execute(arg);
            }

            main.execute("back");
            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            String[] points = getIncorrectPoints();
            for (String point : points) {
                output = main.execute(ids.get(0) + " " + point);
                expect(output).toContain().lines();
                if (anyMissingKeywords(output, "incorrect", "format")) {
                    return CheckResult.wrong("Expected output: \"Incorrect points format.\", but your output was: " + output);
                }
            }

            output = main.execute("imsurethereisnosuchstudentid 1 1 1 1");
            expect(output).toContain().lines();
            if (anyMissingKeywords(output, "no", "student", "found") ||
                    !output.contains("imsurethereisnosuchstudentid")) {
                return CheckResult.wrong("Expected output was: \"No student is found " +
                        "for id=imsurethereisnosuchstudentid.\" but your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 12)
        CheckResult testStudentPoints2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(6);
            for (String arg : credentials) {
                main.execute(arg);
            }
            main.execute("back");

            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            String[] points = getCorrectPoints(6);

            for (int i = 0; i < points.length; i++) {
                output = main.execute(ids.get(i) + " " + points[i]);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "points", "updated")) {
                    return CheckResult.wrong("Expected \"Points updated.\" but your output was " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 13)
        CheckResult testBackFromFind() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("find");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "id", "back", "return")) {
                return CheckResult.wrong("When 'find' command is entered, you program should " +
                        "print \"Enter an id or 'back' to return:\", but your output was: " + output);
            }

            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 14)
        CheckResult testFindByID() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(5);
            for (String arg : credentials) {
                main.execute(arg);
            }
            main.execute("back");

            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            for (int i = 0; i < ids.size(); i++) {
                main.execute(String.format("%s %d %d %d %d", ids.get(i), i, i, i, i));
                main.execute(String.format("%s %d %d %d %d", ids.get(i), i, i, i, i));
            }

            main.execute("back");
            output = main.execute("find");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "id", "back", "return")) {
                return CheckResult.wrong("When 'find' command is entered, you program should " +
                        "print \"Enter an id or 'back' to return:\", but your output was: " + output);
            }

            for (int i = 0; i < ids.size(); i++) {
                output = main.execute(ids.get(i));
                expect(output).toContain(1).lines();
                String expected = String.format(
                        "%s points: Java=%d; DSA=%d; Databases=%d; Spring=%d",
                        ids.get(i), i * 2, i * 2, i * 2, i * 2
                );
                if (incorrectString(output, expected)) {
                    return CheckResult.wrong("Expected output: " + expected +
                            ", but your output was: " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 15)
        CheckResult testBackFromStatistics() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("statistics");
            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 16)
        CheckResult testStatistics1() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("statistics");
            String[] lines = Arrays.stream(output.split("\n"))
                    .filter(Predicate.not(String::isBlank))
                    .toArray(String[]::new);

            if (anyMissingKeywords(lines[0], "course", "details", "back", "quit")) {
                return CheckResult.wrong("When the \"statistics\" command is entered, your " +
                        "program must print: \"Type the name of a course to see details or 'back' " +
                        "to quit:\", but your output was: " + lines[0]);
            }

            if (lines.length < 7) {
                return CheckResult.wrong("Your program should print a header and 6 " +
                        "categories, but you printed only " + lines.length + " lines");
            }

            List<String> categories = List.of("Most popular: n/a", "Least popular: n/a",
                    "Highest activity: n/a", "Lowest activity: n/a", "Easiest course: n/a",
                    "Hardest course: n/a");
            for (int i = 1; i < lines.length; i++) {
                if (incorrectString(lines[i], categories.get(i - 1))) {
                    return CheckResult.wrong("Expected: " + categories.get(i - 1) +
                            ", but your output was " + lines[i]);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 17)
        CheckResult testStatistics2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("statistics");

            List<String> courses = List.of("Java", "DSA", "Databases", "Spring");
            for (String course : courses) {
                String output = main.execute(course);
                String[] lines = output.split("\n");
                if (lines.length < 2) {
                    return CheckResult.wrong("Expected 2 lines, but your output was only " + lines.length + " lines.");
                }

                if (incorrectString(lines[0], course.toLowerCase())) {
                    return CheckResult.wrong("Your first line should be " + course + ", but your output was " + lines[0]);
                }

                if (anyMissingKeywords(lines[1], "id", "points", "completed")) {
                    return CheckResult.wrong("Your second line should be \"id\tpoints\tcompleted\", " +
                            "but your output was " + lines[1]);
                }
            }

            List<String> unknown = Arrays.stream(getUnknownCommands())
                    .filter(str -> courses.stream().noneMatch(it -> it.trim().equalsIgnoreCase(str)))
                    .collect(Collectors.toList());

            for (String course : unknown) {
                String output = main.execute(course);
                if (incorrectString(output, "unknown course")) {
                    return CheckResult.wrong("Expected output: \"Unknown course.\", but your output was: " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 18)
        CheckResult testStatistics3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("statistics");

            main.execute("back");
            if (!main.isWaitingInput()) {
                return CheckResult.wrong("Your program should keep running after the 'back' " +
                        "command is entered");
            }

            String output = main.execute("back");
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should print the hint \"Enter 'exit' to exit the program.\"");
            }

            output = main.execute("exit");
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 19)
        CheckResult testCategories1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            getRandomCredentials(4).forEach(main::execute);

            main.execute("back");
            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            for (String id : ids) {
                main.execute(String.format("%s 5 4 3 1", id));
            }

            main.execute("back");
            lines = expect(main.execute("statistics")).toContain().lines();

            if (anyMissingKeywords(lines.get(1), "java", "dsa", "databases", "spring")) {
                return CheckResult.wrong("Expected most popular: Java, DSA, Databases, Spring, " +
                        "but your output was: " + lines.get(1));
            }

            if (!lines.get(2).toLowerCase().contains("n/a")) {
                return CheckResult.wrong("Expected least popular: n/a, " +
                        "but your output was: " + lines.get(2));
            }

            if (anyMissingKeywords(lines.get(3), "java", "dsa", "databases", "spring")) {
                return CheckResult.wrong("Expected top activity: Java, DSA, Databases, Spring, " +
                        "but your output was: " + lines.get(3));
            }

            if (!lines.get(4).contains("n/a")) {
                return CheckResult.wrong("Expected lowest activity: n/a, " +
                        "but your output was: " + lines.get(4));
            }

            if (anyMissingKeywords(lines.get(5), "java")) {
                return CheckResult.wrong("Expected easiest course: Java, " +
                        "but your output was: " + lines.get(5));
            }

            if (anyMissingKeywords(lines.get(6), "Spring")) {
                return CheckResult.wrong("Expected hardest course: Spring, " +
                        "but your output was: " + lines.get(6));
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 20)
        CheckResult testCategories2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            getRandomCredentials(4).forEach(main::execute);

            main.execute("back");
            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 10 10 10 10", ids.get(0)));
            main.execute(String.format("%s 5 5 5 5", ids.get(1)));
            main.execute(String.format("%s 5 5 5 5", ids.get(2)));
            main.execute(String.format("%s 2 2 2 2", ids.get(3)));

            main.execute("back");
            main.execute("statistics");

            List<String> linesJava = expect(main.execute("Java")).toContain(6).lines();
            List<String> linesDsa = expect(main.execute("DSA")).toContain(6).lines();
            List<String> linesDb = expect(main.execute("Databases")).toContain(6).lines();
            List<String> linesSpring = expect(main.execute("Spring")).toContain(6).lines();

            if (!linesJava.get(2).matches(".+\\s+10\\s+1\\.7\\s?%.*") ||
                    !linesJava.get(3).matches(".+\\s+5\\s+0\\.8\\s?%.*") ||
                    !linesJava.get(4).matches(".+\\s+5\\s+0\\.8\\s?%.*") ||
                    !linesJava.get(5).matches(".+\\s+2\\s+0\\.3\\s?%.*") ||
                    !linesJava.get(2).startsWith(ids.get(0)) ||
                    !linesJava.get(3).startsWith(ids.get(1)) && !linesJava.get(3).startsWith(ids.get(2)) ||
                    !linesJava.get(4).startsWith(ids.get(1)) && !linesJava.get(4).startsWith(ids.get(2)) ||
                    !linesJava.get(5).startsWith(ids.get(3)) ||
                    linesJava.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesJava.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Java student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDsa.get(2).matches(".+\\s+10\\s+2\\.5\\s?%.*") ||
                    !linesDsa.get(3).matches(".+\\s+5\\s+1\\.3\\s?%.*") ||
                    !linesDsa.get(4).matches(".+\\s+5\\s+1\\.3\\s?%.*") ||
                    !linesDsa.get(5).matches(".+\\s+2\\s+0\\.5\\s?%.*") ||
                    !linesDsa.get(2).startsWith(ids.get(0)) ||
                    !linesDsa.get(3).startsWith(ids.get(1)) && !linesDsa.get(3).startsWith(ids.get(2)) ||
                    !linesDsa.get(4).startsWith(ids.get(1)) && !linesDsa.get(4).startsWith(ids.get(2)) ||
                    !linesDsa.get(5).startsWith(ids.get(3)) ||
                    linesDsa.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesDsa.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your DSA student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDb.get(2).matches(".+\\s+10\\s+2\\.1\\s?%.*") ||
                    !linesDb.get(3).matches(".+\\s+5\\s+1\\.0\\s?%.*") ||
                    !linesDb.get(4).matches(".+\\s+5\\s+1\\.0\\s?%.*") ||
                    !linesDb.get(5).matches(".+\\s+2\\s+0\\.4\\s?%.*") ||
                    !linesDb.get(2).startsWith(ids.get(0)) ||
                    !linesDb.get(3).startsWith(ids.get(1)) && !linesDb.get(3).startsWith(ids.get(2)) ||
                    !linesDb.get(4).startsWith(ids.get(1)) && !linesDb.get(4).startsWith(ids.get(2)) ||
                    !linesDb.get(5).startsWith(ids.get(3)) ||
                    linesDb.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesDb.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Databases student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            if (!linesSpring.get(2).matches(".+\\s+10\\s+1\\.8\\s?%.*") ||
                    !linesSpring.get(3).matches(".+\\s+5\\s+0\\.9\\s?%.*") ||
                    !linesSpring.get(4).matches(".+\\s+5\\s+0\\.9\\s?%.*") ||
                    !linesSpring.get(5).matches(".+\\s+2\\s+0\\.4\\s?%.*") ||
                    !linesSpring.get(2).startsWith(ids.get(0)) ||
                    !linesSpring.get(3).startsWith(ids.get(1)) && !linesSpring.get(3).startsWith(ids.get(2)) ||
                    !linesSpring.get(4).startsWith(ids.get(1)) && !linesSpring.get(4).startsWith(ids.get(2)) ||
                    !linesSpring.get(5).startsWith(ids.get(3)) ||
                    linesSpring.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesSpring.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Spring student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 21)
        CheckResult testCategories3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            main.execute("John Doe johnd@email.net");
            main.execute("Jane Spark jspark@yahoo.com");
            main.execute("back");

            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 8 7 7 5", ids.get(0)));
            main.execute(String.format("%s 7 6 9 7", ids.get(0)));
            main.execute(String.format("%s 6 5 5 0", ids.get(0)));
            main.execute(String.format("%s 8 0 8 6", ids.get(1)));
            main.execute(String.format("%s 7 0 0 0", ids.get(1)));
            main.execute(String.format("%s 9 0 0 5", ids.get(1)));

            main.execute("back");
            main.execute("statistics");

            List<String> linesJava = expect(main.execute("Java")).toContain(4).lines();
            List<String> linesDsa = expect(main.execute("DSA")).toContain(3).lines();
            List<String> linesDb = expect(main.execute("Databases")).toContain(4).lines();
            List<String> linesSpring = expect(main.execute("Spring")).toContain(4).lines();

            if (!linesJava.get(2).matches(".+\\s+24\\s+4\\.0\\s?%.*") ||
                    !linesJava.get(3).matches(".+\\s+21\\s+3\\.5\\s?%.*") ||
                    !linesJava.get(2).startsWith(ids.get(1)) || !linesJava.get(3).startsWith(ids.get(0))) {
                return CheckResult.wrong("Your Java student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDsa.get(2).matches(".+\\s+18\\s+4\\.5\\s?%.*") || !linesDsa.get(2).startsWith(ids.get(0))) {
                return CheckResult.wrong("Your DSA student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDb.get(2).matches(".+\\s+21\\s+4\\.4\\s?%.*") ||
                    !linesDb.get(3).matches(".+\\s+8\\s+1\\.7\\s?%.*") ||
                    !linesDb.get(2).startsWith(ids.get(0)) || !linesDb.get(3).startsWith(ids.get(1))) {
                return CheckResult.wrong("Your Databases student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            if (!linesSpring.get(2).matches(".+\\s+12\\s+2\\.2\\s?%.*") ||
                    !linesSpring.get(3).matches(".+\\s+11\\s+2\\.0\\s?%.*") ||
                    !linesSpring.get(2).startsWith(ids.get(0)) || !linesSpring.get(3).startsWith(ids.get(1))) {
                return CheckResult.wrong("Your Spring student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 22)
        CheckResult testNotification1() {
            TestedProgram main = new TestedProgram();
            main.start();

            List<String> output = expect(main.execute("notify")).toContain(1).lines();
            if (output.stream()
                    .map(String::toLowerCase)
                    .allMatch(str -> anyMissingKeywords(str, "total", "0", "notified"))) {
                return CheckResult.wrong("Expected output was \"Total 0 students have been notified.\", " +
                        "but your output was: " + String.join("\n", output));
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 23)
        CheckResult testNotification2() {
            TestedProgram main = new TestedProgram();
            main.start();

            main.execute("add students");
            main.execute("John Doe johnd@email.net");
            main.execute("Jane Spark jspark@yahoo.com");
            main.execute("back");

            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 600 400 0 0", ids.get(0)));
            main.execute("back");

            List<String> output = expect(main.execute("notify")).toContain(7).lines();

            if (!output.get(0).toLowerCase().startsWith("to:") ||
                    !output.get(0).toLowerCase().contains("johnd@email.net") ||
                    !output.get(1).toLowerCase().startsWith("re:") ||
                    anyMissingKeywords(output.get(1), "learning", "progress") ||
                    anyMissingKeywords(output.get(2), "john", "doe", "accomplished") ||
                    !output.get(2).toLowerCase().contains("java") && !output.get(5).toLowerCase().contains("java")) {
                return CheckResult.wrong("You program should have printed the following:\nTo: johnd@email.net\n" +
                        "Re: Your Learning Progress\nHello, John Doe! You have accomplished our Java course!\n" +
                        "but your output was: \n" + output.stream().limit(3).collect(Collectors.joining("\n")));
            }

            if (!output.get(3).toLowerCase().startsWith("to:") ||
                    !output.get(3).toLowerCase().contains("johnd@email.net") ||
                    !output.get(4).toLowerCase().startsWith("re:") ||
                    anyMissingKeywords(output.get(4), "learning", "progress") ||
                    anyMissingKeywords(output.get(5), "john", "doe", "accomplished", "course") ||
                    !output.get(5).toLowerCase().contains("dsa") && !output.get(2).toLowerCase().contains("dsa")) {
                return CheckResult.wrong("You program should have printed the following:\nTo: johnd@email.net\n" +
                        "Re: Your Learning Progress\nHello, John Doe! You have accomplished our DSA course!\n" +
                        "but your output was: \n" + output.stream().limit(3).collect(Collectors.joining("\n")));
            }

            if (anyMissingKeywords(output.get(6).toLowerCase(), "total", "1", "notified")) {
                return CheckResult.wrong("Expected output was \"Total 1 student has been notified.\", but your output was: \n" +
                        String.join("\n", output));
            }

            if (output.stream().map(String::toLowerCase).anyMatch(str ->
                    str.contains("jane") || str.contains("spark") || str.contains("jspark@yahoo.com"))) {
                return CheckResult.wrong("Your notification should not mention Jane Spark");
            }

            output = expect(main.execute("notify")).toContain(1).lines();
            if (output.stream()
                    .map(String::toLowerCase)
                    .allMatch(str -> anyMissingKeywords(str, "total", "0", "notified"))) {
                return CheckResult.wrong("Expected output was \"Total 0 students have been notified\", " +
                        "but your output was: " + String.join("\n", output));
            }

            return CheckResult.correct();
        }

        private boolean anyMissingKeywords(String output, String... keywords) {
            List<String> tokens = Arrays.asList(
                    output.trim().toLowerCase().split("\\W+")
            );

            return !tokens.containsAll(Arrays.stream(keywords)
                    .map(String::toLowerCase)
                    .collect(Collectors.toList()));
        }

        private boolean incorrectString(String output, String model) {
            String normalizedOutput = output.replaceAll("\\W+", "").toLowerCase();
            String normalizedModel = model.replaceAll("\\W+", "").toLowerCase();

            return !normalizedOutput.contains(normalizedModel);
        }

        private String[] getBlankInput() {
            return new String[]{"", "  ", "\t", " \t"};
        }

        private String[] getUnknownCommands() {
            return new String[]{"abc", "quit", "  brexit ", "exi  t", "?", "break",
                    "-exit", "Ctrl+C", "exit please", ":q", "java", "spring", "dsa", "databases"};
        }

        private String[] getCorrectCredentials() {
            return new String[]{"John Smith jsmith@hotmail.com", "Anny Doolittle anny.md@mail.edu",
                    "Jean-Claude O'Connor jcda123@google.net", "Mary Emelianenko 125367at@zzz90.z9",
                    "Al Owen u15da125@a1s2f4f7.a1c2c5s4", "Robert Jemison Van de Graaff robertvdgraaff@mit.edu",
                    "Ed Eden a1@a1.a1", "na'me s-u ii@ii.ii", "n'a me su aa-b'b ab@ab.ab", "nA me 1@1.1"};
        }

        private String[][] getIncorrectCredentials() {
            return new String[][]{
                    {"", "Incorrect credentials"}, {" \t", "Incorrect credentials."},
                    {"name surname", "Incorrect credentials."},
                    {"n surname email@email.xyz", "Incorrect first name."},
                    {"'name surname email@email.xyz", "Incorrect first name."},
                    {"-name surname email@email.xyz", "Incorrect first name."},
                    {"name- surname email@email.xyz", "Incorrect first name."},
                    {"name' surname email@email.xyz", "Incorrect first name."},
                    {"nam-'e surname email@email.xyz", "Incorrect first name."},
                    {"na'-me surname email@email.xyz", "Incorrect first name."},
                    {"na--me surname email@email.xyz", "Incorrect first name."},
                    {"na''me surname email@email.xyz", "Incorrect first name."},
                    {"námé surname email@email.xyz", "Incorrect first name."},
                    {"name s email@email.xyz", "Incorrect last name."},
                    {"name -surname email@email.xyz", "Incorrect last name."},
                    {"name 'surname email@email.xyz", "Incorrect last name."},
                    {"name surnam''e email@email.xyz", "Incorrect last name."},
                    {"name surn--ame email@email.xyz", "Incorrect last name."},
                    {"name s'-urname email@email.xyz", "Incorrect last name."},
                    {"name su-'rname email@email.xyz", "Incorrect last name."},
                    {"name surname- email@email.xyz", "Incorrect last name."},
                    {"name surname' email@email.xyz", "Incorrect last name."},
                    {"name surnámé email@email.xyz", "Incorrect last name."},
                    {"name surname emailemail.xyz", "Incorrect email."},
                    {"name surname email@emailxyz", "Incorrect email."},
                    {"name surname email@e@mail.xyz", "Incorrect email."},
            };
        }

        private String[] getIncorrectPoints() {
            return new String[]{"", "-1 1 1 1", "1 1 2 A", "1 1 1", "1 1 1 1 1"};
        }

        private String[] getCorrectPoints(int n) {
            return Stream.generate(String::new)
                    .limit(n)
                    .map(it -> String.format("%d %d %d %d", nextPoint(), nextPoint(), nextPoint(), nextPoint()))
                    .toArray(String[]::new);
        }

        private int nextPoint() {
            return rnd.nextInt(10) + 1;
        }

        private List<String> parseIds(List<String> lines) {
            try {
                return lines.stream()
                        .skip(1)
                        .map(String::trim)
                        .collect(Collectors.toList());
            } catch (Exception e) {
                throw new WrongAnswer("Error occurred while parsing your output " + e.getMessage());
            }
        }

        private List<String> generateNames(int n) {
            List<String> names = List.of("Shoshana Utica", "Marisa Firman", "Gwenette Anagnos", "Charlena Girardo",
                    "Alexina Belcher", "Karee Antoinetta", "Dolley Panther", "Elysha Quinlan", "Trixie Winer",
                    "Ricki Trovillion", "Amye Uriisa", "Hedwig Wally", "Gwenette Kironde", "Jermaine Naaman",
                    "Olga Rosanne", "Annecorinne Ause", "Aurie Dorisa", "Van Fawnia", "Carmella Campman",
                    "Francesca Francis", "Elwira Florrie", "Nonna Miko", "Natka Herculie", "Roxi Hett", "Brandise Hardan",
                    "Toby Bleier", "Dalia Gleeson", "Emelia Annnora", "Beatrisa Jegar", "Barbara-Anne Chicky",
                    "Ann Agnella", "Lebbie Alabaster", "Leola Whelan", "Starlin Griz", "Anjanette Uis", "Tasha Chem");

            List<String> selectedNames = new ArrayList<>(names);
            Collections.shuffle(selectedNames);
            return selectedNames.stream().limit(n).collect(Collectors.toList());
        }

        private List<String> generateEmails(int n) {
            return IntStream.rangeClosed(1, n).mapToObj(it -> "address" + it + "@mail.com").collect(Collectors.toList());
        }

        private List<String> getRandomCredentials(int n) {
            List<String> names = generateNames(n);
            List<String> emails = generateEmails(n);
            return IntStream.range(0, n)
                    .mapToObj(it -> String.format("%s %s", names.get(it), emails.get(it)))
                    .collect(Collectors.toList());
        }
    }
  learner_created: false
- name: test/tracker/studentManagerTest.java
  visible: true
  text: |-
    package tracker;

    import org.junit.jupiter.api.Assertions;
    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.params.ParameterizedTest;
    import org.junit.jupiter.params.provider.CsvSource;

    class studentManagerTest {

        studentManager sm = new studentManager();

        @ParameterizedTest(name = "{index} => {0} == true")
        @CsvSource({"Steve", "Steve-sing", "Stevey's"})
        void testFirstNameMatchTrue(String name) {
            Assertions.assertTrue(studentManager.matchFirstName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == false")
        @CsvSource({"'", "S.", ".", "1313131", "tom-"})
        void testFirstNameMatchFalse(String name) {
            Assertions.assertFalse(studentManager.matchFirstName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == true")
        @CsvSource({"O'reilly", "Reilly", "Double-barrel", "cheese stick", "c-heese 'stick oman"})
        void testLastNameMatchTrue(String name) {
            Assertions.assertTrue(studentManager.matchLastName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == false")
        @CsvSource({"-eese 'stick oman", "a", "supa'", "1313131"})
        void testLastNameMatchFalse(String name) {
            Assertions.assertFalse(studentManager.matchLastName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == true")
        @CsvSource({"steve50@gmail.com", "danielneedhamdn@gmail.com", "bing@bong.com", "niceguy50@msn.com"})
        void testEmailMatchTrue(String name) {
            Assertions.assertTrue(studentManager.matchEmail(name));

        }

        @ParameterizedTest(name = "{index} => {0} == false")
        @CsvSource({"-eese 'stick oman", "a", "supa'", "1313131", "something@gmailcom"})
        void testEmailMatchFalse(String name) {
            Assertions.assertFalse(studentManager.matchEmail(name));

        }


    }
  learner_created: false
- name: test/tracker/InputMatchTest.java
  visible: true
  text: |-
    package tracker;

    import org.junit.jupiter.api.Assertions;
    import org.junit.jupiter.params.ParameterizedTest;
    import org.junit.jupiter.params.provider.CsvSource;

    import static tracker.InputMatch.*;

    class InputMatchTest {



        @ParameterizedTest(name = "{index} => {0} == true")
        @CsvSource({"Steve", "Steve-sing", "Stevey's"})
        void testFirstNameMatchTrue(String name) {
            Assertions.assertTrue(matchFirstName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == false")
        @CsvSource({"'", "S.", ".", "1313131", "tom-"})
        void testFirstNameMatchFalse(String name) {
            Assertions.assertFalse(matchFirstName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == true")
        @CsvSource({"O'reilly", "Reilly", "Double-barrel", "cheese stick", "c-heese 'stick oman"})
        void testLastNameMatchTrue(String name) {
            Assertions.assertTrue(matchLastName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == false")
        @CsvSource({"-eese 'stick oman", "a", "supa'", "1313131"})
        void testLastNameMatchFalse(String name) {
            Assertions.assertFalse(matchLastName(name));

        }

        @ParameterizedTest(name = "{index} => {0} == true")
        @CsvSource({"steve50@gmail.com", "danielneedhamdn@gmail.com", "bing@bong.com", "niceguy50@msn.com"})
        void testEmailMatchTrue(String name) {
            Assertions.assertTrue(matchEmail(name));

        }

        @ParameterizedTest(name = "{index} => {0} == false")
        @CsvSource({"-eese 'stick oman", "a", "supa'", "1313131", "something@gmailcom"})
        void testEmailMatchFalse(String name) {
            Assertions.assertFalse(matchEmail(name));

        }

        @ParameterizedTest(name = "{index} => {0} == true")
        @CsvSource({"1001 5 5 5 5", "5112 0 0 0 0", "40023 1 0 2 5000", "00001 500 2 0 23"})
        void testPointsAddTrue(String input){
            Assertions.assertTrue(matchAddPoints(input));
        }

        @ParameterizedTest(name = "{index} => {0} == false")
        @CsvSource({"@:@ZXX", "5112 0 0 0 ", "40023 1 0 2 -50", "1001 1 d s"})
        void testPointsAddFalse(String input){
            Assertions.assertFalse(matchAddPoints(input));
        }

    }
  learner_created: false
- name: test/tracker/StudentManagerTest.java
  visible: true
  text: |-
    package tracker;

    import org.junit.After;
    import org.junit.Assert;
    import org.junit.Before;
    import org.junit.jupiter.api.*;

    import java.io.ByteArrayOutputStream;
    import java.io.PrintStream;
    import java.util.List;
    import static org.junit.jupiter.api.Assertions.*;
    import static org.junit.jupiter.params.provider.Arguments.arguments;

    class StudentManagerTest {

        StudentManager studentManager;

        private final PrintStream standardOut = System.out;
        private final ByteArrayOutputStream outputStreamCaptor = new ByteArrayOutputStream();

        @BeforeEach
        void setUp() {
            studentManager = new StudentManager();
            System.setOut(new PrintStream(outputStreamCaptor));

        }

        @AfterEach
        public void tearDown() {
            System.setOut(standardOut);
        }

        public static List<String> userArgumentFactory() {
            return List.of("dan needham dn@gmail.com", "steve needham sn@gmail.com", "joe needham jn@gmail.com", "pete needham pn@gmail.com", "loud needham ln@gmail.com");
        }


        @Test
        void displayEmptyListTest() {
            studentManager.listAllStudents();
            assertEquals("No students found.", outputStreamCaptor.toString().trim());
        }

        @Test
        void addToListTest() {
            for (String input : userArgumentFactory()) {
                String[] inputSplit = input.split(" ");
                studentManager.addToList(inputSplit[0], inputSplit[1], inputSplit[2]);
            }
            Assertions.assertEquals(5, studentManager.getStudentSet().size());
        }

    }
  learner_created: false
- name: test/tracker/StatisticsTest.java
  visible: true
  text: |-
    package tracker;

    import org.junit.jupiter.api.AfterEach;
    import org.junit.jupiter.api.BeforeAll;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;

    import java.io.ByteArrayOutputStream;
    import java.io.PrintStream;
    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class StatisticsTest {

        StudentManager studentManager;
        Statistics statistics;
        private final PrintStream standardOut = System.out;
        private final ByteArrayOutputStream outputStreamCaptor = new ByteArrayOutputStream();

        @BeforeEach
        public void setUp(){
            studentManager = new StudentManager();
            statistics = new Statistics(studentManager);
            System.setOut(new PrintStream(outputStreamCaptor));
            for (String input : userArgumentFactory()) {
                String[] inputSplit = input.split(" ");
                studentManager.addToList(inputSplit[0], inputSplit[1], inputSplit[2]);
            }
            for (String input : pointsUpdateFactory()) {
                studentManager.addPointsFromArrayForTesting(input);
            }


        }

        @AfterEach
        public void tearDown() {
            System.setOut(standardOut);
        }

        public static List<String> userArgumentFactory() {
            return List.of("dan needham dn@gmail.com", "steve needham sn@gmail.com", "joe needham jn@gmail.com", "pete needham pn@gmail.com", "loud needham ln@gmail.com");
        }

        public static List<String> pointsUpdateFactory() {
            return List.of("1001 4 0 0 8", "1002 0 0 0 5", "1003 0 8 0 4", "1004 0 0 0 0", "1005 0 0 0 0");
        }

        @Test
        void calculateMostPopularTest() {
            assertEquals("Spring", statistics.calculateMostPopular());
        }

        @Test
        void calculateLeastPopularTest() {
            assertEquals("Databases", statistics.calculateLeastPopular());
        }

        @Test
        void calculateHighestActivityTest() {
            assertEquals("Spring", statistics.calculateHighestActivity());
        }

        @Test
        void calculateLowestActivityTest() {
            assertEquals("Databases", statistics.calculateLowestActivity());
        }

        @Test
        void calculateEasiestCourseTest() {
            assertEquals("DSA", statistics.calculateEasiestCourse());
        }

        @Test
        void calculateHardestCourseTest() {
            assertEquals("Java", statistics.calculateHardestCourse());
        }

        @Test
        void returnTopLearnersTestTest() {
            assertEquals("100110021003", statistics.returnTopLearnersTest(CourseNames.SPRING));
        }
    }
  learner_created: false
- name: src/tracker/Statistics.java
  visible: true
  text: |
    package tracker;

    import java.math.BigDecimal;
    import java.math.RoundingMode;
    import java.util.*;
    import java.util.stream.Collectors;


    public class Statistics {

        LinkedHashSet<Student> studentSet;
        HashMap<CourseNames, Course> currentCoursesMap;


        public Statistics(StudentManager studentManager) {

            studentSet = studentManager.getStudentSet();
            currentCoursesMap = studentManager.getCurrentCoursesMap();
        }

        public void startCommandLineInterface(Scanner scanner) {
            String mostPop, leastPop, highestActiv, lowestActiv, easiestCourse, hardestCourse;
            if (currentCoursesMap.values().stream().allMatch(course -> course.amountsOfEnrolledStudents() == 0)){
                mostPop = "n/a";
                leastPop = "n/a";
                highestActiv = "n/a";
                lowestActiv = "n/a";
                easiestCourse = "n/a";
                hardestCourse = "n/a";
            } else {
                mostPop = calculateMostPopular();
                leastPop = calculateLeastPopular();
                highestActiv = calculateHighestActivity();
                lowestActiv = calculateLowestActivity();
                easiestCourse = calculateEasiestCourse();
                hardestCourse = calculateHardestCourse();
            }
            System.out.println("Type the name of a course to see details or 'back' to quit:");
            System.out.println(String.format("""
                            Most popular: %s\s
                            Least popular: %s\s
                            Highest activity: %s\s
                            Lowest activity: %s\s
                            Easiest course: %s\s
                            Hardest course: %s""",
                    mostPop, leastPop, highestActiv, lowestActiv, easiestCourse, hardestCourse));

            inputRead: while (scanner.hasNextLine()) {
                String command = scanner.nextLine();

                //back
                if (Objects.equals(command.toLowerCase(), "back")) {
                    break;
                }

                //print stats on
                for (CourseNames course : CourseNames.values()) {
                    if (command.equals(course.label)) {
                        printTopLearners(course);
                        continue inputRead;
                    }
                }

                //inputted course doesn't match
                System.out.println("Unknown course.");
            }
        }

        public String calculateMostPopular() {
            int mostEnrolledStudents = currentCoursesMap.values()
                    .stream()
                    .mapToInt(Course::amountsOfEnrolledStudents)
                    .max()
                    .orElse(-1);
           return currentCoursesMap.values()
                   .stream()
                   .filter(c -> c.amountsOfEnrolledStudents() == mostEnrolledStudents)
                   .map(c -> c.getCourseName().label)
                   .collect(Collectors.joining(", "));
        }

        public String calculateLeastPopular() {
            String returnString;
            int leastEnrolledStudents = currentCoursesMap.values()
                    .stream()
                    .mapToInt(Course::amountsOfEnrolledStudents)
                    .max()
                    .orElse(-1);
            List<String> courseNamesList = currentCoursesMap.values()
                    .stream()
                    .filter(c -> c.amountsOfEnrolledStudents() == leastEnrolledStudents)
                    .map(c -> c.getCourseName().label)
                    .toList();
            if (courseNamesList.size() > 1) {
                returnString = "n/a";
            } else {
                returnString = courseNamesList.get(0);
            }
            return returnString;
        }

        public String calculateHighestActivity() {
            int highestTotalAssignments = currentCoursesMap.values()
                    .stream()
                    .mapToInt(Course::getTotalAssignmentsForCourse)
                    .max()
                    .orElse(-1);
            return currentCoursesMap.values()
                    .stream()
                    .filter(c -> c.getTotalAssignmentsForCourse() == highestTotalAssignments)
                    .map(c -> c.getCourseName().label)
                    .collect(Collectors.joining(", "));
        }

        public String calculateLowestActivity() {
            String returnString;
            int lowestTotalAssignments = currentCoursesMap.values()
                    .stream()
                    .mapToInt(Course::getTotalAssignmentsForCourse)
                    .min()
                    .orElse(-1);
            List<String> lowestActivityAsStrings = currentCoursesMap.values()
                    .stream()
                    .filter(c -> c.getTotalAssignmentsForCourse() == lowestTotalAssignments)
                    .map(c -> c.getCourseName().label)
                    .toList();
            if (lowestActivityAsStrings.size() > 1) {
                returnString = "n/a";
            } else {
                returnString = lowestActivityAsStrings.get(0);
            }
            return returnString;
        }


        public String calculateEasiestCourse() {
            Optional<Map.Entry<CourseNames, Integer>> maxOptional = getTotalAverageAssignmentScoreHashMap().entrySet().stream()
                    .filter((entry) -> entry.getValue() != 0)
                    .max(Comparator.comparing(Map.Entry::getValue));
            String returnString;
            try {
                Map.Entry<CourseNames, Integer> max = maxOptional.orElseThrow(NullPointerException::new);
                returnString = max.getKey().label;
            } catch (NullPointerException e) {
                returnString = "n/a";
            }
            return returnString;
        }

        public String calculateHardestCourse() {
            Optional<Map.Entry<CourseNames, Integer>> minOptional = getTotalAverageAssignmentScoreHashMap().entrySet().stream()
                    .filter((entry) -> entry.getValue() != 0)
                    .min(Comparator.comparing(Map.Entry::getValue));
            String returnString;
            try {
                Map.Entry<CourseNames, Integer> min = minOptional.orElseThrow(NullPointerException::new);
                returnString = min.getKey().label;
            } catch (NullPointerException e) {
                returnString = "n/a";
            }
            return returnString;
        }

        private HashMap<CourseNames, int[]> createCourseNamesHashMapArr() {
            HashMap<CourseNames, int[]> averageScorePerAssignment = new HashMap<>();
            averageScorePerAssignment.put(CourseNames.JAVA, new int[]{0, 0});
            averageScorePerAssignment.put(CourseNames.DSA, new int[]{0, 0});
            averageScorePerAssignment.put(CourseNames.DATABASES, new int[]{0, 0});
            averageScorePerAssignment.put(CourseNames.SPRING, new int[]{0, 0});
            return averageScorePerAssignment;
        }

        private HashMap<CourseNames, Integer> createCourseNamesHashMapInt() {
            HashMap<CourseNames, Integer> averageScorePerAssignment = new HashMap<>();
            averageScorePerAssignment.put(CourseNames.JAVA, 0);
            averageScorePerAssignment.put(CourseNames.DSA, 0);
            averageScorePerAssignment.put(CourseNames.DATABASES, 0);
            averageScorePerAssignment.put(CourseNames.SPRING, 0);
            return averageScorePerAssignment;
        }

        private HashMap<CourseNames, Integer> getTotalAverageAssignmentScoreHashMap() {
            HashMap<CourseNames, int[]> pointsAssignmentsMap = createCourseNamesHashMapArr();
            for (Student student : studentSet) {
                for (CourseNames course : CourseNames.values()) {
                    pointsAssignmentsMap.computeIfPresent(course, (key, val) -> {
                        val[0] = val[0] + student.getPoints().getCoursePoints(course);
                        val[1] = val[1] + student.getPoints().getCourseAssignments(course);
                        return val;
                    });
                }
            }
            HashMap<CourseNames, Integer> averagePointsPerAssignmentMap = createCourseNamesHashMapInt();
            for (CourseNames course: CourseNames.values()) {
                int average = 0;
                if (pointsAssignmentsMap.get(course)[1] > 0) {
                    average = pointsAssignmentsMap.get(course)[0] / pointsAssignmentsMap.get(course)[1];
                }
                averagePointsPerAssignmentMap.put(course,average);
            }
            return averagePointsPerAssignmentMap;
        }

        public void printTopLearners(CourseNames course) {
            Course selectedCourse = currentCoursesMap.get(course);
            List<Student> enrolledStudents = selectedCourse.getEnrolledStudents();
            enrolledStudents.sort(new topLearnerComparator(course));
            //print
            System.out.println(course.label);
            System.out.println(String.format("id\tpoints\tcompleted"));
            for (Student student: enrolledStudents) {
                int totalPoints = student.getPoints().getCoursePoints(course);
                double d = ((double) totalPoints / (double) selectedCourse.completedPoints) * 100;
                BigDecimal decimal = new BigDecimal(d).setScale(1, RoundingMode.HALF_UP);
                System.out.printf("%s\t%d\t%s%%%n", student.getId(), totalPoints,decimal.toString());
            }
        }
        public String returnTopLearnersTest(CourseNames course) {
            Course selectedCourse = currentCoursesMap.get(course);
            List<Student> enrolledStudents = selectedCourse.getEnrolledStudents();
            enrolledStudents.sort(new topLearnerComparator(course));
            StringBuilder sb = new StringBuilder();
            enrolledStudents.forEach(sb::append);
            return sb.toString();

        }

        private static class topLearnerComparator implements Comparator<Student> {

            CourseNames course;

            topLearnerComparator(CourseNames course) {
                this.course = course;
            }

            @Override
            public int compare(Student o1, Student o2) {

                int pointsCompare = Integer.compare(o2.getPoints().getCoursePoints(course), o1.getPoints().getCoursePoints(course));
                int idCompare = Integer.compare(o1.getIdInt(),o2.getIdInt());

                return (pointsCompare == 0) ? idCompare : pointsCompare;
            }
        }
    }
  learner_created: true
- name: src/tracker/StudentManager.java
  visible: true
  text: |
    package tracker;

    import java.util.*;

    import static tracker.InputMatch.*;


    public class StudentManager {

        private LinkedHashSet<Student> studentSet;
        private HashMap<CourseNames, Course> currentCoursesMap;


        public StudentManager() {
            studentSet = new LinkedHashSet<>();
            currentCoursesMap = new HashMap<>();
            for (CourseNames courseName : CourseNames.values()) {
                currentCoursesMap.put(courseName, new Course(courseName));
            }
        }

        public void addToList(String firstName,
                              String lastName,
                              String email) throws IllegalArgumentException {


            boolean success = studentSet.add(new Student(firstName,
                    lastName,
                    email, generateID()));

            if (!success) {
                throw new IllegalArgumentException();
            }
        }

        public void addStudentFromCommandLine(Scanner scanner) {
            System.out.println("Enter student credentials or 'back' to return:");
            int studentsAddedInSession = 0;
            while (scanner.hasNextLine()) {
                String command = scanner.nextLine();

                //back
                if (Objects.equals(command.toLowerCase(), "back")) {
                    String message = "Total " + studentsAddedInSession + " students have been added";
                    System.out.println(message);
                    break;
                }

                String[] splitBySpace = command.split(" ");

                //incorrect credentials
                if (command.isEmpty() || command.isBlank() || splitBySpace.length < 3) {
                    System.out.println("Incorrect credentials");
                    continue;
                }

                //break string into parts
                String firstName = splitBySpace[0];
                String lastName = String.join(" ", Arrays.copyOfRange(splitBySpace, 1, splitBySpace.length - 1));
                String email = splitBySpace[splitBySpace.length - 1];

                //all match add student to list
                if (matchFirstName(firstName) && matchLastName(lastName) && matchEmail(email)) {
                    try {
                        addToList(firstName, lastName, email);
                    } catch (IllegalArgumentException e) {
                        System.out.println("This email is already taken.");
                        continue;
                    }
                    studentsAddedInSession++;
                    System.out.println("The student has been added.");
                    continue;
                }

                if (!matchFirstName(firstName)) {
                    System.out.println("Incorrect first name.");
                    continue;
                }

                if (!matchLastName(lastName)) {
                    System.out.println("Incorrect last name.");
                    continue;
                }
                if (!matchEmail(email)) {
                    System.out.println("Incorrect email.");
                }

            }
        }

        public void addPointsFromCommandLine(Scanner scanner) {
            System.out.println("Enter an id and points or 'back' to return");
            while (scanner.hasNextLine()) {
                String command = scanner.nextLine();

                //back
                if (Objects.equals(command.toLowerCase(), "back")) {
                    break;
                }

                //input matches
                if (matchAddPoints(command)) {
                    String[] inputs = command.split(" ");
                    String id = inputs[0];
                    try {
                        Student found = findStudentByID(id);
                        int[] inputsAsPointsArray = Arrays.stream(inputs).skip(1)
                                .mapToInt(Integer::valueOf)
                                .toArray();
                        ArrayList<CourseNames> enrolledCourses =
                                found.getPoints().addPointsFromArray(inputsAsPointsArray);
                        if (!enrolledCourses.isEmpty()) {
                            for (CourseNames courseName : enrolledCourses) {
                                currentCoursesMap.get(courseName).addStudentToCourse(found);
                            }
                        }
                        System.out.println("Points updated");
                        //id not found
                    } catch (NoSuchElementException e) {
                        System.out.println(String.format("No student is found for id=%s", id));
                    }
                    continue;
                }

                //incorrect entry default
                System.out.println("Incorrect points format.");
            }
        }

        public void findStudentFromCommandLine(Scanner scanner) {
            System.out.println("Enter an id and points or 'back' to return");
            while (scanner.hasNextLine()) {
                String command = scanner.nextLine();

                //back
                if (Objects.equals(command.toLowerCase(), "back")) {
                    break;
                }

                //input in correct format
                if (command.matches("[0-9]+")) {
                    try {
                        Student found = findStudentByID(command);
                        System.out.println(found.getPointsAsString());
                        continue;
                    } catch (Exception ignored) {

                    }
                }

                //incorrect entry default
                System.out.println(String.format("No student is found for id=%s.", command));
            }
        }


        public void listAllStudents() {
            if (studentSet.isEmpty()) {
                System.out.println("No students found.");
            } else {
                System.out.println("Students:");
                studentSet.forEach(System.out::println);
            }
        }

        public Student findStudentByID(String id) throws NoSuchElementException {
            return studentSet.stream().filter(s -> s.getId().equals(id))
                    .findFirst()
                    .orElseThrow(NoSuchElementException::new);
        }

        public void addPointsFromArrayForTesting(String command) {
            if (matchAddPoints(command)) {
                String[] inputs = command.split(" ");
                String id = inputs[0];
                try {
                    Student found = findStudentByID(id);
                    int[] inputsAsPointsArray = Arrays.stream(inputs).skip(1)
                            .mapToInt(Integer::valueOf)
                            .toArray();
                    ArrayList<CourseNames> enrolledCourses =
                            found.getPoints().addPointsFromArray(inputsAsPointsArray);
                    if (!enrolledCourses.isEmpty()) {
                        for (CourseNames courseName : enrolledCourses) {
                            currentCoursesMap.get(courseName).addStudentToCourse(found);
                        }
                    }
                    System.out.println("Points updated");
                    //id not found
                } catch (NoSuchElementException e) {
                    System.out.println(String.format("No student is found for id=%s", id));
                }
            }
        }

        public LinkedHashSet<Student> getStudentSet() {
            return studentSet;
        }

        public HashMap<CourseNames, Course> getCurrentCoursesMap() {
            return currentCoursesMap;
        }

        private String generateID() {
            int id = studentSet.size() + 1;
            id = 1000 + id;
            return Integer.toString(id);
        }

    }
  learner_created: true
- name: src/tracker/Student.java
  visible: true
  text: |
    package tracker;

    public class Student {

        private final String id;
        private final String firstName;
        private final String lastName;
        private final String email;

        private CoursePoints points;


        public Student(String firstName,
                       String lastName,
                       String email,
                       String id) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.email = email;
            this.id = id;
            points = new CoursePoints();
        }

        public String getPointsAsString() {
            return String.format("%s points: Java=%d; DSA=%d; Databases=%d; Spring=%d", id, points.getCoursePoints(CourseNames.JAVA),
                    points.getCoursePoints(CourseNames.DSA), points.getCoursePoints(CourseNames.DATABASES), points.getCoursePoints(CourseNames.SPRING));
        }

        public int[] returnPointsInArray() {
            return points.getCoursePointsArray();
        }

        public String getId() {
            return id;
        }

        public int getIdInt() {
            return Integer.parseInt(id);
        }

        public String getFirstName() {
            return firstName;
        }

        public String getLastName() {
            return lastName;
        }

        public String getEmail() {
            return email;
        }

        public CoursePoints getPoints() {
            return points;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Student student = (Student) o;

            return email.equals(student.email);
        }

        @Override
        public int hashCode() {
            return email.hashCode();
        }

        @Override
        public String toString() {
            return id;
        }


    }
  learner_created: true
- name: src/tracker/InputMatch.java
  visible: true
  text: |
    package tracker;

    public class InputMatch {

        static boolean matchFirstName(String firstName) {
            String regex = "^(?=.{2,100}$)[a-zA-Z]+(?:[-'][a-zA-Z]+)*$";
            return firstName.matches(regex);
        }

        static boolean matchLastName(String lastName) {
            String regex = "^(?=.{2,100}$)[a-zA-Z ]+(?:[-'][a-zA-Z ]+)*$";
            return lastName.matches(regex);
        }

        static boolean matchEmail(String email) {
            String emailRegex = "[a-zA-Z0-9\\.]+@[a-zA-Z0-9]+\\.[a-zA-Z0-9]+";
            return email.matches(emailRegex);
        }

        static boolean matchAddPoints(String input) {
            String inputRegex = "[0-9a-zA-Z]+( [0-9]+){4}";
            return input.matches(inputRegex);
        }
    }
  learner_created: true
- name: src/tracker/CourseNames.java
  visible: true
  text: |
    package tracker;

    public enum CourseNames {

        JAVA("Java", 600),
        DSA("DSA", 400),
        DATABASES("Databases", 480),
        SPRING("Spring", 550);

        public final String label;
        public final int completedPoints;

        CourseNames(String label, int completedPoints) {
            this.label = label;
            this.completedPoints = completedPoints;
        }
    }
  learner_created: true
- name: src/tracker/Course.java
  visible: true
  text: |
    package tracker;

    import java.util.*;

    public class Course {

        CourseNames courseName;
        int completedPoints;
        private List<Student> enrolledStudents;

        public Course(CourseNames courseName) {
            this.courseName = courseName;
            enrolledStudents = new ArrayList<>();
            this.completedPoints = courseName.completedPoints;
        }

        public void addStudentToCourse(Student student) {
            enrolledStudents.add(student);
        }
        public int amountsOfEnrolledStudents(){
            return enrolledStudents.size();
        }

        public CourseNames getCourseName() {
            return courseName;
        }

        public List<Student> getEnrolledStudents() {
            return enrolledStudents;
        }

        public int getTotalAssignmentsForCourse() {
            int totalAssignments= 0;
            for (Student student : getEnrolledStudents()) {
                for (CourseNames name : CourseNames.values()) {
                    totalAssignments = totalAssignments + student.getPoints().getCourseAssignments(name);
                }
            }
            return totalAssignments;
        }
    }
  learner_created: true
- name: src/tracker/CoursePoints.java
  visible: true
  text: |
    package tracker;

    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.concurrent.atomic.AtomicBoolean;

    public class CoursePoints {

        private HashMap<CourseNames, int[]> coursesPointsMap;

        public CoursePoints() {
            coursesPointsMap = new HashMap<>(4);
            for (CourseNames course : CourseNames.values()) {
                coursesPointsMap.put(course, new int[]{0, 0});
            }
        }

        public ArrayList<CourseNames> addPointsFromArray(int[] points) throws IllegalArgumentException {
            ArrayList<CourseNames> enrolledCourses = new ArrayList<>();
            int numberOfCourses = CourseNames.values().length;
            if (points.length > numberOfCourses) {
                throw new IllegalArgumentException();
            }
            for (int i = 0; i < numberOfCourses; i++) {

                if (addPointsForCourse(CourseNames.values()[i], points[i])) {
                    enrolledCourses.add(CourseNames.values()[i]);
                }
                ;
            }
            return enrolledCourses;
        }

        //returns true, if this is the first time student has been awarded points in that course
        private boolean addPointsForCourse(CourseNames course, int points) {
            AtomicBoolean enrolled = new AtomicBoolean(false);
            coursesPointsMap.compute(course, (key, val) -> {
                if (val[0] == 0 && points > 0) {
                    enrolled.set(true);
                }
                val[0] = val[0] + points;
                if (points > 0) val[1]++;
                return val;
            });
            return enrolled.get();
        }

        public int getCoursePoints(CourseNames course) {
            return coursesPointsMap.get(course)[0];
        }

        public int[] getCoursePointsArray() {
            return coursesPointsMap.values().stream().mapToInt((arr) -> arr[0]).toArray();
        }

        public int getCourseAssignments(CourseNames course) {
            return coursesPointsMap.get(course)[1];
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/14400#comment
status: Unchecked
record: -1
